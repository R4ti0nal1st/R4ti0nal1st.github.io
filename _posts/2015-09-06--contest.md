---
layout: post
title: 'Мой первый contest по программированию'
date: 2015-09-06 13:12
comments: true
categories: 
---
Ну, честно говоря, не совсем первый, но это было так давно, что не считается.

Встал вчера с мыслью, что надо что-то сделать и меня потянуло проверить, что сейчас проходит, но ничего тематического (вроде machine learning) не хотелось. Это было бы ешё более страшно, чем просто соревнование по программированию. Приложения CodeHorizon на планшете (агрегатор) подсказало мне, что есть некий "Week of Code - 17". Не зная что это я тыкнул и попал на HackerRank. "Да я там зарегистрирован!", подумал я. (Я там инода решаю задачки по Clojure.) Решено!

# Язык, среда и прочее

Не знал, какой язык для решения выбрать. В итоге остановился на C++. Давно им не пользовался, но с ним у меня опыта больше чем со всеми остальными вместе взятыми. Я в последнее время страшно его недолюбливаю, после того, как увлёкся функциональными вещами, ну да ладно.

С языком решено, как быть дальше? Нужна среда для разработки. Играясь с Clojure, JavaScript(хороший, кстати, язык, вещи делаются легко и без напряжения) и Python, я слишком привык к REPL. Вообще, работать с динамическими языками гораздо продуктивнее. Но сейчас речь шла о C++. Нужно было, что-то решать.

На моём основном компьютере стоит Windows и VS2012. Мне нужен проект для кода, плюс ещё один для тестов. Попробовал что-то сделать, но всё быстро упёрлось в том, что компилятор там старый и даже не может использовать initialization list для вектора. Так что я быстро отказался от этой затеи, и переехал на ноутбук с Linux, где у меня заготовлен маленький шаблон для задачек с LeetCode: <https://gist.github.com/iloginov/77d91926d9a11b411f7c>. В итоге, адаптировать этот шаблон и перенести тест из условия первой задачи заняло минуты 3-4, что в несколько раз меньше, чем было потрачено на игры с VS2012. Лёд тронулся!

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

#include "gmock/gmock.h"

using namespace std;

vector<int> solution(int n)
{
	vector<int> res = {0, 0};
	return res;
}

TEST(FindTheRobot, Zero) {
	auto res = std::vector<int> {0, 0};
	ASSERT_THAT(solution(0), testing::Eq(res));
}

int main(int argc, char** argv) {
	testing::InitGoogleMock(&argc, argv);

	return RUN_ALL_TESTS();
}
```

# Задачи

Опишу здесь то, что оказалось неожиданными. Сами условия не буду приводить -- легко найти на сайте.

## Find the Robot

Тут всё просто. Но я забыл про большие вводы, поэтому дополнительные кейсы отвалились по таймауту (о чём я узнал через несколько часов, потому что они запускаются в 16:00 UTC). Позор!

## Count Fridays the 13th

Ооо! Эта задача вызвала у меня много эмоций. И дело вовсе не в задаче, а в C++.

Дело в том, что я уже совсем забыл, что простые и привычные вещи в других языка в стране Эдварда Руки-Ножницы(<http://habrahabr.ru/post/196110/>) делаются совсем непросто.

Задача формулируется просто: найти количество пятниц 13е, между двумя датами. Казалось бы, всё просто, ан нет.

Как узнать день недели по дате? StackOverflow сразу говорит ответ: <https://stackoverflow.com/questions/5797814/date-to-day-of-the-week-algorithm>. Сейчас я уже разобрался в чём дело, но у меня оно не заработало.

Пример, 13 марта 2015, как раз пятница:

``` cpp
#include <ctime>
#include <iostream>

int main(void)
{
	std::tm time_in = { 0, 0, 0, 13, 3, 2015 - 1900 };

	std::time_t time_temp = std::mktime( & time_in );
	std::tm const *time_out = std::localtime( & time_temp );

	std::cout << time_out->tm_wday << std::endl;
	return 0;
}
```

```
1
```

Кто видит ошибку -- молодец. Я упорно не видел. И считаю, что это корявость системной библиотеки.

В чём же состоит ошибка? Тот кто, проектировал структуру `tm`, во первых, он ошибся с секундами (сделал их не 61, а 62, что исправили в C++11, почему секунд должно быть 61 можно погуглить в сети, суть -- раз в несколько лет набегает ещё одна секунда и её надо куда-то деть), но он ещё сделал все параметры в структуре zero-based, кроме дня. Ладно бы, все. Но часть так, часть иначе! Я же считал, что день и месяц нумеруются с единицы. Хороший это интерфейс? Я считаю, что плохой.

Но, поскольку, я только сейчас, пока пишу этот пост разобрался в чём дело, а тогда надо было решать задачку, расскажу, что же я сделал.

Я нашёл в сети интересный метод конвертации дат в число и обратно: <http://alcor.concordia.ca/~gpkatch/gdate-algorithm.html>. Всем рекомендую знать, что оно бывает. Плюс, что я узнал реализуя его -- надо использовать 8мибайтовые целые, иначе не будет работать.

Осталось вычислить день недели. Ну тут вообще было не хитро. Gdate линейно конвертирует даты в номер дня. Вычислить разницу в днях ничего не стоит. Плюс сакральное знание, что 1 января 1900 года был понедельник.

Задача решена. Я научился новому. Profit!

## Roads Building

Тут задача поинтереснее. Надо было посидеть и подумать. В итоге -- 2 Дейкстры и перебор.

Я сразу посмотрел на размеры входных данных. Максимальный граф, представленный в виде матрицы смежности занимал бы 9Gb. Это явно не то, что ждёт проверочная система. Вот тут <https://www.hackerrank.com/environment> можно ознакомиться с лимитами. Для C++ лимит памяти -- 512Mb.

Поэтому граф надо представлять в виде списков смежности.

Я взял представление графа с Rosetta Code:

``` cpp
struct neighbor {
	vertex_t target;
	weight_t weight;
	neighbor(vertex_t arg_target, weight_t arg_weight)
		: target(arg_target), weight(arg_weight) { }
 };
  
typedef std::vector<std::vector<neighbor>> adjacency_list_t;
```

В итоге я получил timeout в большинстве дополнительных тестов:

<img class="center" src="http://user-image.logdown.io/user/14217/blog/13433/post/294626/kuLt9MCeShmsVT8M5ZI1_timeout.png" alt="timeout.png">

Надо разбираться, что там с производительностью. Есть шанс, что я использовал неправильный алгоритм, конечно. Но думаю, что я не так пользуюсь контейнерами.

И опять же, написать обвязку для C++ было дольше, чем само решение. Наверняка, у тех, кто регулярно этим занимается, есть заготовленные стандартные вещи, типа Дейкстры.

Но задача была интересная и доставила удовольствие.

## Cross the River

Тут всё было проще че в предыдущей задаче. Хоть сложность и заявлена выше.

Заполнить граф + Белман-Форд. Готово!

## Garden Planning и Counting Permutations

Хороших идей по этим задачам у меня нет. К сожалению.

# Итоги

Мои результаты оказались лучше, чем я рассчитывал. Хоть я и решил полностью всего 2 задачи, а ещё по двум прошли только базовые тесты, я чуть-чуть (< 1%) не дотянул до серебрянной медали.

Это был интересный опыт.

Уроки, которые я вынес:

  - Удобное окружение -- очень важно.
  - Заготовки -- важно.
  - Надо разбираться с производительностью стандартных контейнеров. Наверное, я их не так использую. Очень много дополнительных тестов отваливается по timeout'у. 
  - Программирование отнимает больше времени, чем само решение.

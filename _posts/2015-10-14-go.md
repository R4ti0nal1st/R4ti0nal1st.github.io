---
layout: post
title: 'Go'
date: 2015-10-14 12:37
comments: true
categories: 
---

Несколько дней назад я прочёл 2 небольшие книжки по Go:

  - [An Introduction to Programming in Go](https://www.golang-book.com/books/intro)
  - [The Little Go Book](http://openmymind.net/The-Little-Go-Book/)

Обе они довольно легко читаются и неплохо дополняют друг друга. Например, про сечения (slice) написано плохо. Я совсем не сразу понял, что это такое. У меня остались вопросы про конкурентность, в частности, как именно работает планировщик, и некоторые другие, но, в целом, всё легко и ясно.

Статьи на сайте языка разъяснили мне про синтаксис объявлений, про сечения и некоторые другие интересные мне вещи.

Для меня, правда, оказалось неожиданным, что авторы решились ввести указатели наравне со сборщиком мусора и расшаренную память (с необходимыми примитивами синхронизации) вместе с каналами и message passing.

Однако, не кажется, что у сборщика мусора могут быть проблемы с указателями, потому что в языке отсутсвует арифметика над указателями.

Введение shared memory, наверное, сделано для пущей возможности оптимизации, хотя не очень очевидно.

Меня сейчас занимает вопрос про работу планировщика. Я немного разобрался, когда он срабатывает, но это отлично от привычных потоков операционной системы. В книге про Haskell, я прочёл разумное замечание, зачем вычислять результат, пока его никто не попросил? Чувствую, что и здесь что-то в этом роде. И что достаточно большой класс задач можно так решить. Но какие задачи не подходят для решения таким подходом?

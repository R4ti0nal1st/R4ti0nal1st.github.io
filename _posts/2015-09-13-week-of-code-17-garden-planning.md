---
layout: post
title: 'Week of Code - 17: Garden Planning'
date: 2015-09-13 19:52
comments: true
categories: 
---
Поизучав решение участников, которые успешно сдали эту задачу, я смог разобраться, как её можно решить. Могу только сказать, что изучать код алгоритмистов -- не самое простое дело. Читаемость стоит на последнем месте.

# Формулировка

Дана карта вот такого вида

```
.##
.?.
??.
#?#
```

Вместо `?` можно ставить либо `#`, либо `.`. Требуется найти количество вариантов расставить эти знаки (чтобы `?` не осталось), так, чтобы
  - область занимаемая `.` была связной,
  - между любыми двумя клетками, где стоит `.` существовал только один путь по `.`.

# Как понять, что карта удовлетворяет этим требованиям

Допустим, что мы можем перебрать все возможные варианты расстановки символов на месте знаков вопроса. Допустим, что укладываемся и по времени и по памяти. Но как проверить, что карта удовлетворяет требуемым условиям.

Один из вариантов -- перебрать все пары клетов, где стоит `.` и проверить, что существует путь из одной в другую и этот путь единственнен.

Обе задачи достаточно легко решаются. (TODO: Как?) Но сложность всего этого добра просто зашкаливает. В лучшем случае, наивная реализация имеет сложность \\( O(N^3M^3) \\).

Как можно сделать лучше?

## Выявление связных компонент

Для начала научимся понимать, сколько связных компонент есть на карте. Это что-то вроде задачи о протекании.

Пусть есть вот такая бинарная строка: `.#..#.#...`, закодируем её следущим образом: `0#11#2#333`. Пока идут точки, ставим какую-то цифру, как только встречаются решётки, переходим к следующей цифре и увеличиваем счётчик компонент на 1.

Переходим к следующей строке.


```
0#11#2#333				// components = 4
.##...#..#
```

Делаем то же самое. Только начинаем со следующей цифры.


```
0#11#2#333			// components = 4
4##555#66#			// components = 7
```

Теперь делаем следующее. Проходимся по второй строке слева направо и делаем следующую процедуру: если в текущей позиции цифра и над тоже цифра, то меняем все вхождения текущей цифры во второй строке на цифру сверху и уменьшаем счётчик связных компонент на 1.

Получаем следующее:

```
0#11#2#333			// components = 4
0##222#33#			// components = 3
```

Количество связных компонент было 7. 4 поменяли на 0. Количество компонент стало 6. 5 поменяли на 1. Количество компонент стало 5. Потом 1 поменяли на 2. Количичество компонент стало 4. 6 поменяли на 3. Количество компонент стало 3.

Оставляем последнюю строку и продолжаем дальше.

Дошли до низу. Теперь можно сказать, сколько связных компонент было на карте. Общая суть, думаю, понятна. Делается за \\( O(NM) \\).

## Как понять, что образуется не простой путь

Для того чтобы понять, что происходит образование не простого пути, чуть-чуть модифицируем процедуру для подсчёта связных компонет, что описана выше.

Будем менять числа не после полной раскраски строки, а по мере продвижения. Встретили цифру сверху -- поменяли все вхождения текущей до текущей позиции и сделали текущей ту, что встретили сверху.

Теперь понять, что образуется не простой путь тривиально. Если слева и сверху от текущей позиции стоит одна и та же цифра и на текущей позиции `.`, то образуется не простой путь.

Вот несколько примеров:


```
000
0.#
```

```
000#
0#00
00.#
```

Если мы встречаем такую ситуацию, то дальше можно не продолжать проверку.

## Как понять, что гарантированно образуется больше одно связной компоненты

Можно ли модифицировать процедуру для подсчёта связных компонент, чтобы останавливаться, как только гарантированно образуется больше одной связной компоненты?

Да, можно.

Представить себе это можно следующим образом. Компонента как бы протекает вниз и вбок, где может. Гарантированное образование компоненты происходит, если она ещё не протекла вниз и больше не сможет.

Модифицируем метод ещё раз. Будем обрабатывать следующую строку на месте текущей. Мы пока не пользовались ни чем кроме текущего символа сверху, так что это ни на что из предыдущего не повлияет.

При данном алгоритме у компоненты больше нету шансов протечь, если
  - она ешё не протекла (слева от текущей позиции нет соответствующей цифры),
  - она уже не сможет протечь (справа от текущец позиции нет соотвествующей цифры, справа идет предыдущая строка пока что, и на текущую позицию мы должны поставить `#`).

Единственная тонкость состоит в том, что чтобы гарантированно сказать, что образовалась вторая компонента, а не закончилась первая, в текущей строке должна быть ещё одна компонента. Ситуация ниже вполне корректна:


```
000###
######
```

TODO: Код, который получился.

# Решение с помощью динамического программирования

Выше описан способ, как можно свести всю карту к двум строкам для проверки необходимых требований.

Допустим, что мы сгенерировали все возможные карты и теперь проверяем их на допустимость. Сначала первую строку у всех карт, потом вторую строку у всех карт и т.д. Когда мы дойдём до последней строки, то сможем пересчитать количество корректных спопособов.

Однако, начало у всех карт будет одинаковым, да и многие места в середине будут совпадать. Зачем делать одну и ту же работу по несколько раз?

Будем делать следующее. Будем идти по исходной карте и делать проверку. Когда дойдём до знака вопроса, будем  раздваивать строку. Сколько строк дойдёт до конца -- столько и будет вариантов.

Но тут строки тоже могут дублироваться, поэтому будем вести только уникальные строки и рядом их количество.